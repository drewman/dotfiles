#+TITLE: Drew's Emacs Configuration
#+AUTHOR: Drew Bruce
#+EMAIL: drew@drewbruce.com

* About
This configuration is a derivative of Matthew Zeng's excellent [[https://github.com/MatthewZMD/.emacs.d][config]]. Also, heavily inspired by [[https://www.spacemacs.org/][spacemacs]] and [[https://github.com/hlissner/doom-emacs/][doom emacs]].
* Emacs Configuration
:PROPERTIES:
:header-args: :tangle yes :comments org :results output silent
:END:
** Startup Optimizations
Some optimizations to speed up start-up time.
#+BEGIN_SRC emacs-lisp
  (defvar better-gc-cons-threshold 67108864 ; 64mb
    "The default value to use for `gc-cons-threshold'.

  If you experience freezing, decrease this.  If you experience stuttering, increase this.")

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold better-gc-cons-threshold)
              (setq file-name-handler-alist file-name-handler-alist-original)
              (makunbound 'file-name-handler-alist-original)))
  ;; Garbage Collect when Emacs is out of focus and avoid garbage collection when using minibuffer.
  (add-hook 'emacs-startup-hook
            (lambda ()
              (if (boundp 'after-focus-change-function)
                  (add-function :after after-focus-change-function
                                (lambda ()
                                  (unless (frame-focus-state)
                                    (garbage-collect))))
                (add-hook 'after-focus-change-function 'garbage-collect))
              (defun gc-minibuffer-setup-hook ()
                (setq gc-cons-threshold (* better-gc-cons-threshold 2)))

              (defun gc-minibuffer-exit-hook ()
                (garbage-collect)
                (setq gc-cons-threshold better-gc-cons-threshold))

              (add-hook 'minibuffer-setup-hook #'gc-minibuffer-setup-hook)
              (add-hook 'minibuffer-exit-hook #'gc-minibuffer-exit-hook)))
#+END_SRC
** Package Management
*** Package Sources
+ Add the "melpa" source because all the good stuff is on MELPA.
+ Add the "org" source to get (more) recent org-mode builds than what is included with emacs.
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-user-dir (expand-file-name "elpa" user-emacs-directory))

  (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+END_SRC
*** Configure package manager
#+begin_src emacs-lisp
  (unless (bound-and-true-p package--initialized)
    (setq package-enable-at-startup nil)          ; To prevent initializing twice
    (package-initialize))

  ;; set use-package-verbose to t for interpreted .emacs,
  ;; and to nil for byte-compiled .emacs.elc.
  (eval-and-compile
    (setq use-package-verbose (not (bound-and-true-p byte-compile-current-file))))
#+end_src

*** Macros
Use-package macros are very helpful for managing and configuring all the packages I install.
+ If use-package isn't installed, install it.
+ Set use-package 
+ Load use-package
#+BEGIN_SRC emacs-lisp
  ;; Install use-package if not installed
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-and-compile
    (setq use-package-always-ensure t)
    (setq use-package-expand-minimally t)
    (setq use-package-compute-statistics t)
    (setq use-package-enable-imenu-support t))

  (eval-when-compile
    (require 'use-package)
    (require 'bind-key))
#+END_SRC

*** Auto Package Update
Use ~auto-package-update~ to automatically update packages every week.
#+begin_src emacs-lisp
  (use-package auto-package-update
    :if (not (daemonp))
    :custom
    (auto-package-update-interval 7) ;; in days
    (auto-package-update-prompt-before-update t)
    (auto-package-update-delete-old-versions t)
    (auto-package-update-hide-results t)
    :config
    (auto-package-update-maybe))
#+end_src

*** Load Path
Add some add-ons (particularly =ox-confluence= because =org-plus-contrib= was breaking =org-agenda=) via ~load-path~.
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/lisp/")
#+end_src

*** Org-mode
Due to some buggy nonsense. Putting this up before anything else gets done to prevent any possible issues.
#+begin_src emacs-lisp
  ;; copied from org-mode website installation instruction
  (unless package-archive-contents    ;; Refresh the packages descriptions
    (package-refresh-contents))
  (setq package-load-list '(all))     ;; List of packages to load
  (unless (package-installed-p 'org)  ;; Make sure the Org package is
    (package-install 'org))           ;; installed, install it if not
#+end_src

** Keybinds
*** Evil
**** colon commands
I prefer to have :q commands just close the window and not Emacs. Only ~:quit~ should exit Emacs.
#+BEGIN_SRC emacs-lisp
  (defun my/evil-save-and-close()
      "Helper function to map to :wq."
      (interactive)
      (save-buffer)
      (my/evil-close))

  (defun my/evil-close()
    "Helper function to kill buffer or close window if there's more than one"
    (interactive)
    (if (> (count-windows) 1)
        (evil-window-delete)
      (kill-buffer)))

  (use-package evil
      :custom
      (evil-want-C-u-scroll t)
      (evil-disable-insert-state-bindings t)
      :config
      (evil-ex-define-cmd "q" 'my/evil-close)
      (evil-ex-define-cmd "wq" 'my/evil-save-and-close)
      (evil-ex-define-cmd "quit" 'evil-save-and-quit)
      (evil-mode 1))
#+END_SRC
**** <Esc> key
Allow 'jk' to substitute for escape in normal mode if pressed quickly enough.
#+BEGIN_SRC emacs-lisp
  (use-package evil-escape
      :requires evil
      :custom
      (evil-escape-excluded-states '(normal multiedit emacs motion))
      (evil-escape-key-sequence "jk")
      :config
      (evil-escape-mode))
#+END_SRC

*** Global binds
**** ~general.el~ makes managing keybinds extremely easy.
#+BEGIN_SRC emacs-lisp
  (use-package general)
#+END_SRC
**** Define special functions to open specific files. Binding this to ~SPC f <>~
#+BEGIN_SRC emacs-lisp
  (defun my/open-config()
      (interactive)
      (find-file "~/.emacs.d/Drew.org"))

  (defun my/open-worklog()
      (interactive)
      (find-file "~/org/notes/worklog.org"))
#+END_SRC
**** Define spacemacs-like keybinds.
Defining these at the top of the file so if other regions crash the init, I still have keybinds.
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "SPC") (general-simulate-key "C-c"))
  (general-define-key
        :states '(normal visual insert emacs)
        :prefix "C-c"
        "x" '(counsel-M-x :which-key "M-x")

        "a" 'avy-goto-char-timer

        "b" '(:ignore t :which-key "buffer/bookmark")
        "bb" 'counsel-switch-buffer
        "bc" 'kill-current-buffer
        "bd" 'counsel-bookmarked-directory
        "bD" 'bookmark-delete
        "be" 'eval-buffer
        "bi" 'avy-goto-line
        "bj" 'avy-goto-char-timer
        "bk" 'kill-buffer
        "bl" '(evil-switch-to-windows-last-buffer :which-key "last buffer")
        "bm" 'counsel-bookmark
        "bu" 'bookmark-bmenu-list
        "bw" 'kill-buffer-and-window

        "e" 'eww

        "f" '(:ignore t :which-key "file")
        "ff" '(counsel-find-file :which-key "find file")
        "fl" '(my/open-worklog :which-key "open worklog")
        "fi" '(imenu :which-key "jump in file")
        "fj" '(counsel-file-jump :which-key "jump to file")
        "fp" '(my/open-config :which-key "open personal config")
        "fs" 'save-buffer
        "fu" 'undo-tree-visualize
        "fM" 'mkdir
        "fN" 'create-empty-file

        "g" '(:ignore t :which-key "magit")
        "gb" 'magit-branch-and-checkout
        "gc" 'magit-clone
        "gd" 'magit-diff-working-tree
        "gg" 'magit-status
        "gi" 'magit-init
        "gl" 'magit-log-current

        "h" '(:keymap help-map :which-key "help")

        "l" 'avy-goto-line
        "i" 'imenu

        "o" '(:ignore t :which-key "org")
        "oa" 'org-agenda
        "oo" '(org-roam-capture :which-key "org capture")
        "or" 'org-roam
        "os" '(deft :which-key "search org files")

        "p" '(:keymap projectile-command-map :package projectile :which-key "projectile")

        "s" '(:ignore t :which-key "shell")
        "se" '(aweshell-new :which-key "new eshell buffer")
        "sI" '(my/insert-shell-command :which-key "insert shell cmd in buffer")
        "sr" '(my/open-remote-shell :which-key "open remote shell")
        "ss" '(shell :which-key "vanilla shell")
        "st" '(aweshell-dedicated-toggle :which-key "toggle eshell popup")

        "t" '(:ignore t :which-key "tabs")
        "tj" 'tab-bar-switch-to-next-tab
        "tk" 'tab-bar-switch-to-prev-tab
        "tq" 'tab-bar-close-tab
        "tt" 'tab-bar-new-tab

        "w" '(:keymap evil-window-map :which-key "window"))
        "z" 'undo-tree-visualize
#+END_SRC

**** Add a local leader as a placeholder for mode specific keybinds.
#+BEGIN_SRC emacs-lisp
  (general-create-definer my/local-leader-def
    :states '(normal visual insert emacs)
    :prefix "C-c m"
    "" '(:ignore t :which-key "local"))
#+END_SRC
**** Define some helpful non-leader keybinds
#+BEGIN_SRC emacs-lisp
  (general-define-key
       :states 'visual
       "C-c c" 'comment-or-uncomment-region)

  (general-define-key
   "C--" 'text-scale-decrease
   "C-+" 'text-scale-increase
   "C-=" 'text-scale-increase)

  (general-define-key
       :states '(normal motion)
       "/" 'swiper-isearch)
  (general-define-key
   :keymaps 'evil-window-map
   "d" 'delete-other-windows
   "n" 'evil-window-new
   "o" 'other-window)
   
  (general-define-key
   :states 'insert
   :keymaps '(org-mode-map prog-mode-map)
   [tab] 'mz/smarter-tab-to-complete
   "TAB" 'mz/smarter-tab-to-complete
   "C-n" 'next-line
   "C-p" 'previous-line
   "C-e" 'end-of-line
   "C-a" 'beginning-of-line-next)
#+END_SRC
*** Evil Collection
#+begin_src emacs-lisp
  (use-package evil-collection
    :config
    (evil-collection-init))
#+end_src


** env
When running code from within Emacs, ideally it will run exactly the same as if it were run in terminal.
For that purpose, ~exec-path-from-shell~ is used so all programs will be run similarly.
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
    :config
    (exec-path-from-shell-copy-env "WORKON_HOME")
    (exec-path-from-shell-initialize))
#+END_SRC

** Look and Feel
*** Line Numbers
I like to always display line numbers when I'm programming.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+END_SRC
*** Tab Bar
I like using tabs to give me a visual representation of my workspaces. Built-in tab bar works great.
#+begin_src emacs-lisp
  (setq tab-bar-show 1)
  (setq tab-bar-close-button-show 'selected)
  (setq tab-bar-new-button-show nil)
  (setq tab-bar-new-tab-choice "*scratch*")
#+end_src

*** UI Elements
Remove unnecessary UI elements: scroll-bar, tool-bar, menu-bar, tool-tips.
#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (menu-bar-mode -1)
  (global-eldoc-mode -1)
#+END_SRC

*** Ring bell
I dislike both an audio and a visual ring-bell. So remove the ring-bell altogether.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

*** Font
Set the default display to use "JetBrains Mono" font with size 15.
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil :family "JetBrains Mono" :height 150)
#+END_SRC

*** Theme
Using the modus-vivendi theme due to it's excellent customization.
#+BEGIN_SRC emacs-lisp
  (use-package modus-vivendi-theme
      :demand t
      :custom
      (modus-vivendi-theme-bold-constructs t)
      (modus-vivendi-theme-slanted-constructs t)
      (modus-vivendi-theme-completions 'opinionated)
      (modus-vivendi-theme-fringes 'intense)
      (modus-vivendi-theme-intense-hl-line t)
      (modus-vivendi-theme-intense-paren-match t)
      (modus-vivendi-theme-org-blocks 'rainbow)
      (modus-vivendi-theme-scale-headings t)
      (modus-vivendi-theme-variable-pitch-headings t)
      :config
      (load-theme 'modus-vivendi t))
#+END_SRC

*** Parenthesis and other delimiters
I like the matching parenthesis to match to help me understand the context of where I'm at.
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC
This might be a bit redundant with ~show-paren-mode~, but this helps me with contexts.
#+BEGIN_SRC emacs-lisp
;; turn my lisp into fruit loops
(use-package rainbow-delimiters
    :defer
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

*** Modeline
The default modeline is, in my opinion, dated and ugly. ~doom-modeline~ is the best modeline that I have tried thus far. I increase the ~vcs-max-length~ due to extra long branch names that I often use.
Also, testing out Powerline. The big sell here is that the time doesn't hide when I lose focus on the window.
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
      :disabled t
      :hook (after-init . doom-modeline-mode)
      :init
      (display-time-mode 1)
      :custom
      (doom-modeline-vcs-max-length 40)
      (doom-modeline-indent-info t))

  (use-package powerline
    :init
    (defpowerline powerline-minor-modes "")
    :config
    (display-time-mode)
    (powerline-default-theme))

  ;; (use-package telephone-line
  ;;   :init
  ;;   (setq telephone-line-lhs
  ;;         '((evil   . (telephone-line-evil-tag-segment))
  ;;           (accent . (telephone-line-vc-segment))
  ;;           (nil    . (telephone-line-projectile-segment
  ;;                      telephone-line-buffer-name-segment
  ;;                      telephone-line-buffer-modified-segment))))
  ;;   (setq telephone-line-rhs
  ;;         '((nil    . (telephone-line-misc-info-segment))
  ;;           (accent . (telephone-line-simple-major-mode-segment))
  ;;           (evil   . (telephone-line-hud-segment))))
  ;;   :config
  ;;   (display-time-mode 1)
  ;;   (telephone-line-mode t))
#+END_SRC
**** Time in Modeline
I like to have the time displayed in my modeline.
#+begin_src emacs-lisp
(display-time-mode 1)
#+end_src

*** Yes or no prompt
Simpler yes/no prompts to save keystrokes.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Icons
A lot of the addons that I'm using have support for ~all-the-icons~ to use fancy icons in my completion buffer, startpage, etc. This makes the emacs experience feel more modern.
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
#+END_SRC

*** Startpage
Ideally I would have a custom start page (org file). For now ~dashboard~ suits my purposes and doesn't seem overly resource heavy.
#+BEGIN_SRC emacs-lisp
(use-package page-break-lines)
(use-package dashboard
    :requires (page-break-lines all-the-icons)
    :custom
    (dashboard-startup-banner 'logo)
    :config
    ;; force dashboard to add hooks when command line args are present (making compatible with chemacs)
    (add-hook 'after-init-hook (lambda () (dashboard-insert-startupify-lists)))
    (add-hook 'emacs-startup-hook '(lambda ()
                                     (switch-to-buffer "*dashboard*")
                                     (goto-char (point-min))
                                     (redisplay))))
  ;; WOULD BE BETTER TO JUST OPEN A CUSTOM ORG FILE
  ; (setq inhibit-startup-screen t)
  ; (setq initial-buffer-choice "~/.custom-emacs.d/init.el")
#+END_SRC

*** Indentation
I pulled this off of emacs-for-vimmers. I prefer 4 spaces to tabs.
#+BEGIN_SRC emacs-lisp
(setq default-tab-width 4)
(setq tab-width 4)
(setq default-fill-column 80)
(setq fill-column 80)
(setq-default evil-indent-convert-tabs nil)
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(setq-default evil-shift-round nil)
#+END_SRC

*** Window Splitting
Golden ratio allows for nicely utilizing your active buffer while still being able to see what's going on in the other frames. Currently disabled until I have time to tweak it into submission.
#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio
    :disabled
    :init
    (setq golden-ratio-exclude-modes 'magit-mode)
    :config
    (golden-ratio-mode 1))
#+END_SRC

*** Buffer Switching
I dislike the default for prepending numbers to buffers with the same name. This changes them to use the path to delineate them.
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+END_SRC emacs-lisp

*** Line breaking
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode)
#+END_SRC
** Editing
*** Undo-Tree
#+begin_src emacs-lisp
  (use-package undo-tree
    :custom
    (undo-tree-visualizer-diff t)
    (undo-tree-visualizer-timestamps t)
    :config
    (global-undo-tree-mode))
#+end_src
*** Code Folding
Turn on basic code folding. To enable ~zo~ and ~zc~ evil keybinds.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'hs-minor-mode)
  (add-hook 'org-mode-hook 'hs-minor-mode)
#+END_SRC
*** Line highlighting
#+begin_src emacs-lisp :tangle yes
  (global-hl-line-mode)
*** Avy
Package that let's me jump around to a specific point of text.
#+begin_src emacs-lisp
  (use-package avy)
#+end_src
*** evil-matchit
#+begin_src emacs-lisp
  (use-package evil-matchit
    :config
    (global-evil-matchit-mode 1))
#+end_src

*** evil-surround 
#+begin_src emacs-lisp
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
#+end_src

** Completion
*** Framework 
Currently using Ivy. I've found that it works the best with the least amount of configuration to the other frameworks I've tried. Prost uses icomplete, which would be interesting to try, however it requires a lot of configuration to get correct. I've never really given helm a try because it seems so heavy. However, it also has some really nice functionality.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
      :custom
      (swiper-goto-start-of-match t))

  (use-package counsel)

  (use-package ivy
      :init
      (use-package amx :defer t)
      :custom
      (ivy-count-format " (%d/%d) ")
      (ivy-wrap t)
      (setq ivy-re-builders-alist
            '((t . ivy--regex-ignore-order)))
      :bind (:map ivy-minibuffer-map
             ("TAB" . ivy-alt-done)
             ("C-l" . ivy-alt-done)
             ("C-j" . ivy-next-line)
             ("C-k" . ivy-previous-line)
             ("C-o" . ivy-dispatching-done)
             :map ivy-switch-buffer-map
             ("C-k" . ivy-previous-line)
             ("C-j" . ivy-next-line)
             ("C-d" . ivy-switch-buffer-kill)
             :map ivy-reverse-i-search-map
             ("C-k" . ivy-previous-line)
             ("C-j" . ivy-next-line)
             ("C-d" . ivy-reverse-i-search-kill))
      :hook (ivy-mode . visual-line-mode)
      :config
      (ivy-mode 1))

  (use-package ivy-rich
      :requires ivy
      :init
      (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
      :config
      (ivy-rich-mode 1))

  (use-package all-the-icons-ivy-rich
      :requires (ivy-rich all-the-icons)
      :config
      (all-the-icons-ivy-rich-mode 1))
#+END_SRC

*** Which-key
I love having the suggestions, so if I ever forget my binds I can just look.
#+BEGIN_SRC emacs-lisp
(use-package which-key
    :custom
    (which-key-frame-max-height 20)
    (which-key-sort-order 'which-key-description-order)
    :config
    (which-key-mode))
#+END_SRC

*** Spelling
Flyspell just works and works well.
#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :hook (org-mode . flyspell-mode))

(use-package flyspell-correct
  :after flyspell
  :bind (:map flyspell-mode-map ("C-;" . flyspell-correct-wrapper)))

(use-package flyspell-correct-ivy
  :after flyspell-correct)
#+END_SRC

** Help menus
Improved help menus with ~helpful~
#+BEGIN_SRC emacs-lisp
  (use-package helpful
      :defer t
      :custom
      (counsel-describe-function-function #'helpful-callable)
      (counsel-describe-variable-function #'helpful-variable))
  (general-define-key
      :prefix "C-h"
      "f" 'helpful-callable
      "G" 'customize-group
      "v" 'helpful-variable
      "k" 'helpful-key
      "F" 'helpful-function
      "C" 'helpful-command
      "h" 'helpful-at-point)
  (general-def helpful-mode-map
       :states '(normal motion emacs)
       "q" 'quit-window)
#+END_SRC

** Scratch
Prefer a scratch message that reminds me of the keybinds I always forget.
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message ";;C-j evaluate\n;;C-x C-e evalutate-last-sexp;;C-x C-f to save buffer\n\n")
#+END_SRC

** Development
*** Completion
Company is the default. Everything supports it and it works well. Pulled from [[https://github.com/MatthewZMD/.emacs.d][Matthew Zeng's config]] and tweaked a bit. I really like company to only start once I ask for it and tabs to cycle through the options. 
#+BEGIN_SRC emacs-lisp
    ;; SECTION -- DEV
  (use-package company
      :init
      (add-hook 'after-init-hook 'global-company-mode)
      :bind
      (:map company-active-map
            ([tab] . company-complete-common-or-cycle)
            ("TAB" . company-complete-common-or-cycle)
            ([ret] . company-complete)
            ("RET" . company-complete)
            ([backtab] . company-select-previous)
            ("BACKTAB" . company-select-previous)
            ("C-n" . company-select-next)
            ("C-p" . company-select-previous))
      :custom
      (company-minimum-prefix-length 2)
      (company-tooltip-align-annotations t)
      (company-idle-delay nil)
      (company-show-numbers t))
#+END_SRC
      
#+BEGIN_SRC emacs-lisp
    (defun mz/smarter-tab-to-complete ()
    "Try to `org-cycle', `yas-expand', and `yas-next-field' at current cursor position.
  If all failed, try to complete the common part with `company-complete-common'"
    (interactive)
    (if yas-minor-mode
        (let ((old-point (point))
              (old-tick (buffer-chars-modified-tick))
              (func-list '(org-cycle yas-expand yas-next-field)))
          (catch 'func-suceed
            (dolist (func func-list)
              (ignore-errors (call-interactively func))
              (unless (and (eq old-point (point))
                           (eq old-tick (buffer-chars-modified-tick)))
                (throw 'func-suceed t)))
            (company-indent-or-complete-common 0)))))
#+END_SRC

**** Company TabNine
     Add TabNine completion to Company.
     #+BEGIN_SRC emacs-lisp
       (use-package company-tabnine
         :disabled t
         :defer 1
         :custom
         (company tabnine-max-num-results 9)
         :hook
         (kill-emacs . company-tabnine-kill-process)
         :config
         (add-to-list 'company-backends #'company-tabnine))
     #+END_SRC
*** Checkers
Flycheck to show syntax issues
#+BEGIN_SRC emacs-lisp
(use-package flycheck
    :init (global-flycheck-mode))
#+END_SRC

*** Source Control
Magit is an excellent porcelain for git. One of the main reasons to use Emacs.
#+BEGIN_SRC emacs-lisp
(use-package magit
    :defer t
    :custom
    (magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
    (magit-save-repository-buffers t)
    :config
    (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC
Add evil keybinds for magit.
#+BEGIN_SRC emacs-lisp
      (use-package evil-magit
          :after (magit evil)
          :config
          (evil-magit-init))
#+END_SRC

*** Projects
Projectile is great for doing project related activities.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
      :defer t
      :custom
      (projectile-completion-system 'ivy)
      :config
      (projectile-mode +1))
#+END_SRC

*** Python
**** Python-mode
#+begin_src emacs-lisp
  (setq python-shell-interpreter "ipython"
        python-shell-interpreter-args "-i --simple-prompt")
#+end_src

Function pulled from [[https://dougie.io/emacs/django-shell/][dougie.io]] blog.
#+begin_src emacs-lisp
  (defun django-shell ()
    (interactive)
    (let ((python-shell-interpreter (read-file-name "Locate manage.py "))
          (python-shell-interpreter-args "shell_plus"))
      (run-python (python-shell-calculate-command) nil t)))
#+end_src


**** Anaconda
~anaconda-mode~ is extremely easy to setup and get working well. However, it isn't nearly as strong as some of the other Python modes out there. Would like to try something else when I have time.
#+BEGIN_SRC emacs-lisp
  (use-package anaconda-mode
    :defer t
    :config
    (add-hook 'python-mode-hook 'anaconda-mode))

  (use-package company-anaconda
    :defer t
    :after (company anaconda-mode)
    :config
    (add-to-list 'company-backends 'company-anaconda))
#+END_SRC
**** Pyenv
#+begin_src emacs-lisp
  (use-package pyenv-mode
    :custom
    (python-shell-virtualenv-path "~/.pyenv/versions")
    :hook
    (python-mode . pyenv-mode))
#+end_src

*** Haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :defer t
    :config
    (evil-set-initial-state 'interactive-haskell-mode 'insert)
    (haskell-indentation-mode +1)
    (interactive-haskell-mode +1))

  (use-package company-ghc
    :defer t
    :config
    (add-to-list 'company-backends 'company-ghc))

  (use-package flycheck-haskell
      :defer t
      :after (haskell-mode flycheck)
      :init (add-hook 'haskell-mode-hook #'flycheck-haskell-setup))

  (my/local-leader-def haskell-mode-map
       "r" 'haskell-interactive-bring
       "k" 'haskell-interactive-mode-clear
       "c" 'haskell-compile
       "t" 'haskell-process-do-type
       "i" 'haskell-process-do-info
       "l" 'haskell-process-load-or-reload)

  (my/local-leader-def interactive-haskell-mode-map
       "c" 'haskell-interactive-mode-clear
       "l" 'haskell-process-load-or-reload)
#+END_SRC

*** Elisp
**** Keybinds
#+BEGIN_SRC emacs-lisp
(my/local-leader-def emacs-lisp-mode-map
     "x" 'eval-last-sexp
     "e" 'eval-expression)
#+END_SRC
*** Web
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode)))
#+END_SRC

** Shell
#+begin_src emacs-lisp
  (defun my/insert-shell-command (CMD)
    (interactive "s")
    (insert (shell-command-to-string CMD)))
#+end_src

#+begin_src emacs-lisp
  (use-package aweshell
    :load-path (lambda () (expand-file-name "lisp/aweshell" user-emacs-directory)))
#+end_src

#+begin_src emacs-lisp
  (defun my/open-remote-shell (host)
    (interactive "s<user>@<host>: ")
    (let ((default-directory (concat "/ssh:" host ":~")))
          (shell)))
#+end_src


** Org
*** Setup
Custom function to strip properties out of comments during tangles.
#+BEGIN_SRC emacs-lisp
  (defun my/remove-properties (str)
    (string-join (seq-filter (lambda (st) (not (string-prefix-p ":" st))) (split-string str "\n")) "\n"))
#+END_SRC
Custom refiles with a helper function to rebuild targets. It would be nice to have this hooked to automatically run during an initial save in org mode.
#+BEGIN_SRC emacs-lisp
  (defun my/build-refile-targets ()
    (mapcar 'abbreviate-file-name
            (split-string
             (shell-command-to-string "find -L ~/org -name '*.org'") "\n")))

  (defvar my/refile-targets (my/build-refile-targets))

  (defun my/rebuild-refile-targets ()
    (interactive)
    (setq my/refile-targets (my/build-refile-targets)))

  ;;(defvar my/refile-targets
    ;; (mapcar 'abbreviate-file-name
    ;;        (split-string
    ;;         (shell-command-to-string "find -L ~/org -name '*.org'") "\n")))
#+END_SRC
Capture templates
#+BEGIN_SRC emacs-lisp
  (defvar my/capture-templates
      '(
          ("b" "bullet" entry (function org-roam--capture-get-point)
          "* %?\n"
          :file-name "inbox.org"
          :head "#+title: ${title}\n#+author: %n\n#+date: %<%m/%d/%Y>\n\n"
          :unnarrowed t)
          ("t" "todo" entry (function org-roam--capture-get-point)
          "* TODO %?\n"
          :file-name "inbox.org"
          :head "#+title: ${title}\n#+author: %n\n#+date: %<%m/%d/%Y>\n\n"
          :unnarrowed t)
          ("s" "slip" plain (function org-roam--capture-get-point)
          "%?"
          :file-name "${slug}"
          :head "#+title: ${title}\n#+author: %n\n#+date: %<%m/%d/%Y>\n\n"
          :unnarrowed t)))

  (defvar my/dailies-capture-templates
      '(
          ("d" "daily" plain (function org-roam--capture-get-point)
          ""
          :immediate-finish t
          :file-name "%<%Y-%m-%d>"
          :head "#+title: %<%Y-%m-%d>\n#+roam_tags\n\n")))
#+END_SRC
Configure org and associated packages.
#+BEGIN_SRC emacs-lisp
  (use-package org
      :custom
      (org-directory "~/org/")
      (org-babel-process-comment-text 'my/remove-properties)
      (org-agenda-files (list "~/org/notes/important_dates.org" "~/org/notes/worklog.org" "~/org/notes/inbox.org"))
      (org-agenda-window-setup 'current-window)
      (org-agenda-span 10)
      (org-agenda-start-on-weekday nil)
      (org-refile-targets '((my/refile-targets :maxlevel . 1)))
      (org-link-file-path-type "absolute")
      (org-ellipsis " ▼ ")
      (org-hide-emphasis-markers t)
      (org-M-RET-may-split-line '((item . nil)))
      (org-insert-heading-respect-content t)
      (org-lowest-priority ?D)
      (org-priority-faces '((?A . (:foreground "red" :weight bold))
                            (?B . (:foreground "orange"))
                            (?C . (:foreground "yellow"))
                            (?D . (:foreground "green"))))
      :config
      (require 'ox-confluence)
      (add-hook 'org-mode-hook 'org-indent-mode)
      (add-hook 'org-mode-hook 'visual-line-mode))

  (use-package org-roam
    :after org
    :custom
    (org-roam-directory "~/org/notes")
    (org-roam-capture-templates my/capture-templates)
    (org-roam-dailies-capture-templates my/dailies-capture-templates)
    :config
    (add-hook 'after-init-hook 'org-roam-mode))

  (use-package org-superstar
    :after org
    :init
    (setq org-hide-leading-stars t)
    :config
    (add-hook 'org-mode-hook (lambda() (org-superstar-mode 1))))

  (use-package org-fancy-priorities
    :hook
    (org-mode . org-fancy-priorities-mode)
    :config
    (setq org-fancy-priorities-list '("HIGH" "MEDIUM" "LOW" "OPTIONAL")))

  (use-package visual-fill-column
    :init
    (setq visual-fill-column-width 120)
    (setq visual-fill-column-center-text t)
    :hook (org-mode . visual-fill-column-mode))
#+END_SRC
*** Custom Functions
Insert Jira ticket links with ease.
#+begin_src emacs-lisp
  (defun my/insert-nike-jira-link (ticket-number)
    (interactive "sTicket Number: ")
    (insert "[[https://jira.nike.com/browse/" ticket-number "][" ticket-number "]]"))
#+end_src

Mimics the behavior of calling eww but works with org links. If over link, open with eww, otherwise just call eww for search prompt.
#+begin_src emacs-lisp
  (defun my/org-open-link-at-point-with-eww ()
    (interactive)
    (let ((browse-url-browser-function 'eww-browse-url))
      (condition-case nil
          (org-open-at-point-global)
        ((user-error "No link found") (call-interactively 'eww)))))
#+end_src
*** Deft
#+BEGIN_SRC emacs-lisp
  (use-package deft
    :config
    (setq deft-directory "~/org")
    (setq deft-recursive t)
  )
#+END_SRC
**** Keymaps
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps 'deft-mode-map
   :states 'normal
   "q" 'kill-current-buffer)

  (general-define-key
   :keymaps 'deft-mode-map
   :states 'insert
   "C-n" 'evil-next-line
   "C-p" 'evil-previous-line)
#+END_SRC
**** Evil Org
#+begin_src emacs-lisp
  (use-package evil-org
    :after org
    :config
    (add-hook 'org-mode-hook 'evil-org-mode)
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+end_src

*** Keymaps
#+BEGIN_SRC emacs-lisp
  (my/local-leader-def org-mode-map
      "c" 'org-confluence-export-as-confluence
      "i" 'org-roam-insert
      "I" 'org-roam-insert-immediate
      "j" 'my/insert-nike-jira-link
      "k" 'org-toggle-link-display
      "l" 'my/org-open-link-at-point-with-eww
      "n" 'org-narrow-to-subtree
      "r" 'org-refile
      "v" 'org-babel-load-in-session
      "w" 'widen
      "x" 'org-export-dispatch
      "D" 'org-babel-demarcate-block
      "I" 'org-roam-insert-immediate
      "T" 'org-babel-tangle)

  (general-define-key
   :keymaps 'org-mode-map
   "C-c e" '(my/org-open-link-at-point-with-eww :which-key "eww"))

  (general-define-key
   :keymaps 'org-mode-map
   :states 'normal
   "gk" 'org-previous-visible-heading
   "gj" 'org-next-visible-heading
   "gK" 'org-backward-heading-same-level
   "gJ" 'org-forward-heading-same-level)
#+END_SRC
I don't like using the Meta key because of it's awkward placement on my keyboard. However, the control key is rebound to ~CAPS LOCK~ and it works beautifully. So, I'll just use that instead. There is an issue where I can't get ~general.el~ to make ~<C-return>~ behave like ~<M-return>~. This was the compromise that got it working.
#+begin_src emacs-lisp :tangle yes
  (defun my/org-c-return ()
  "Custom function to bind to <C-return>"
    (interactive)
    (org-meta-return)
    (evil-insert-state))

  (evil-define-key '(normal insert) 'evil-org-mode
    (kbd "<C-return>") 'my/org-c-return)
#+end_src

** Gnus
*** Config
#+begin_src emacs-lisp
  (use-package gnus
    :config
    (setq gnus-select-method '(nntp "news.gwene.org")))
#+end_src

** Elfeed
Elfeed works so much better in doom. Copying the setup.
*** Config
#+begin_src emacs-lisp
    (use-package elfeed
      :init
      (setq elfeed-db-directory (concat user-emacs-directory "~/org/elfeed/db/")
            elfeed-enclosure-default-dir (concat user-emacs-directory "~/org/elfeed/enclosures/"))
      :config
      (setq elfeed-search-filter "@2-week-ago +unread"
            elfeed-sort-order 'ascending
            shr-max-image-proportion 0.8)
      (make-directory elfeed-db-directory t)
      (make-directory elfeed-enclosure-default-dir t))

    (use-package elfeed-org
      :after elfeed
      :custom
      (rmh-elfeed-org-files (list "~/org/elfeed.org"))
      :config
      (elfeed-org))
    (use-package elfeed-goodies
      :after elfeed
      :config
      (elfeed-goodies/setup))
#+end_src

*** Keybinds
#+begin_src emacs-lisp
  (general-def elfeed-search-mode-map
     :states 'normal
     "q" 'elfeed-kill-buffer
     "r" 'elfeed-search-update--force)
#+end_src


** Snippets
Love me some snippets to save keystrokes.
#+begin_src emacs-lisp
  (use-package yasnippet
    :init
    (use-package yasnippet-snippets :after yasnippet)
    :config
    (yas-global-mode 1))
#+end_src
